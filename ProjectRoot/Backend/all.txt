
# package.json
{
    "name": "vacation-backend",
    "version": "1.0.0",
    "scripts": {
        "dev": "ts-node-dev src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "test": "jest"
    },
    "dependencies": {
        "bcrypt": "^5.1.0",
        "cors": "^2.8.5",
        "dotenv": "^16.0.3",
        "express": "^4.18.2",
        "jsonwebtoken": "^9.0.0",
        "multer": "^1.4.5-lts.2",
        "mysql2": "^3.2.0",
        "sequelize": "^6.25.3"
    },
    "devDependencies": {
        "@types/bcrypt": "^5.0.0",
        "@types/cors": "^2.8.17",
        "@types/express": "^4.17.14",
        "@types/jest": "^29.5.0",
        "@types/jsonwebtoken": "^9.0.1",
        "@types/multer": "^1.4.12",
        "@types/node": "^18.11.18",
        "jest": "^29.5.0",
        "ts-jest": "^29.0.5",
        "ts-node-dev": "^2.0.0",
        "typescript": "^4.9.5"
    }
}

# tsconfig.json
{
    "compilerOptions": {
      "target": "ES2018",
      "module": "CommonJS",
      "rootDir": "src",
      "outDir": "dist",
      "esModuleInterop": true,
      "strict": true,
      "skipLibCheck": true,
      "typeRoots": [
        "./src/types",
        "./node_modules/@types"
      ]
    },
    "include": ["src"]
  }
  
# src/types/express/index.d.ts
// Backend/src/types/express/index.d.ts

// DO NOT include any top-level import or export statements except the “export {}” (see note below)

declare global {
    namespace Express {
      interface Request {
        user?: {
          id: number;
          role: string;
          firstName: string;
          lastName: string;
        };
      }
    }
  }
  
  // The following line tells TypeScript this file is a module,
  // but does not prevent global augmentation.
  export {};
  
# src/types/express.d.ts
declare namespace Express {
    export interface Request {
      user?: {
        id: number;
        role: string;
        firstName: string;
        lastName: string;
      }
    }
  }
  
# src/config/db.ts
import { Sequelize } from "sequelize";
import dotenv from "dotenv";

// Load environment variables from .env if present
dotenv.config();

// Read DB config from environment or use defaults
const DB_HOST = process.env.DB_HOST || "localhost";
const DB_USER = process.env.DB_USER || "root";
const DB_PASSWORD = process.env.DB_PASSWORD || "";
const DB_NAME = process.env.DB_NAME || "vacation_db";

export const sequelize = new Sequelize(DB_NAME, DB_USER, DB_PASSWORD, {
  host: DB_HOST,
  dialect: "mysql",
  logging: false,  // disable logging SQL queries
  define: {
    freezeTableName: true  // use model names as table names without pluralizing
  }
});

# src/tests/middleware.test.ts
import { authMiddleware } from "../middlewares/auth.middleware";
import { adminMiddleware } from "../middlewares/admin.middleware";
import jwt from "jsonwebtoken";

// Helper to create a dummy request, response, and next for testing
const createMockRes = () => {
  const res: any = {};
  res.status = jest.fn().mockReturnValue(res);
  res.json = jest.fn().mockReturnValue(res);
  return res;
};

describe("Auth Middleware", () => {
  const SECRET = process.env.JWT_SECRET || "changeme";

  it("should return 401 if no Authorization header is present", () => {
    const req: any = { headers: {} };
    const res = createMockRes();
    const next = jest.fn();

    authMiddleware(req, res, next);
    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({ message: "Unauthorized" });
    expect(next).not.toHaveBeenCalled();
  });

  it("should allow request if a valid token is provided", () => {
    // Create a valid token for a dummy user
    const token = jwt.sign({ id: 42, role: "user" }, SECRET);
    const req: any = { headers: { authorization: `Bearer ${token}` } };
    const res = createMockRes();
    const next = jest.fn();

    authMiddleware(req, res, next);
    expect(next).toHaveBeenCalled();            // next() called, meaning authentication passed
    expect(req.user.id).toBe(42);
    expect(req.user.role).toBe("user");
  });
});

describe("Admin Middleware", () => {
  it("should return 403 if user is not admin", () => {
    const req: any = { user: { role: "user" } };
    const res = createMockRes();
    const next = jest.fn();

    adminMiddleware(req, res, next);
    expect(res.status).toHaveBeenCalledWith(403);
    expect(res.json).toHaveBeenCalledWith({ message: "Forbidden" });
    expect(next).not.toHaveBeenCalled();
  });

  it("should allow request if user is admin", () => {
    const req: any = { user: { role: "admin" } };
    const res = createMockRes();
    const next = jest.fn();

    adminMiddleware(req, res, next);
    expect(next).toHaveBeenCalled();
  });
});

# src/middlewares/admin.middleware.ts
import { Request, Response, NextFunction } from "express";

export function adminMiddleware(req: Request, res: Response, next: NextFunction) {
  // authMiddleware should run before this, so req.user is set
  console.log("Admin Middleware: ", req.user);
  if (!req.user || req.user.role !== "admin") {
    return res.status(403).json({ message: "Forbidden" });
  }
  next();
}

# src/middlewares/auth.middleware.ts
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";

const JWT_SECRET = process.env.JWT_SECRET || "changeme";

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers["authorization"];
  if (!authHeader) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  const token = authHeader.split(" ")[1];
  if (!token) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  try {
    const payload = jwt.verify(token, JWT_SECRET) as {
      id: number;
      role: string;
      firstName: string;
      lastName: string;
    };
    req.user = payload;  // now recognized because of your declaration merge
    next();
  } catch (err) {
    return res.status(401).json({ message: "Unauthorized" });
  }
}

# src/utils/jwt.ts
import jwt from "jsonwebtoken";
const JWT_SECRET = process.env.JWT_SECRET || "changeme";
const JWT_EXPIRES_IN = "1d";  // token validity duration

interface UserPayload {
  id: number;
  role: string;
  firstName: string;
  lastName: string;
}

export function generateToken(userPayload: UserPayload): string {
  // Sign a JWT with user id and role (and optionally name) in payload
  return jwt.sign(userPayload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

# src/utils/uploader.ts
import multer from "multer";
import path from "path";

// Configure disk storage for uploaded images
const storage = multer.diskStorage({
  destination: function(req, file, cb) {
    cb(null, "uploads/");  // ensure this folder exists
  },
  filename: function(req, file, cb) {
    // Generate a unique filename: original name with a timestamp
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname);  // preserve original extension
    cb(null, uniqueSuffix + ext);
  }
});

// Only accept image files (basic validation)
function fileFilter(req: Express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) {
  if (file.mimetype.startsWith("image/")) {
    cb(null, true);
  } else {
    cb(new Error("Only image files are allowed!"));
  }
}

export const upload = multer({ storage, fileFilter });

# src/models/user.model.ts
import { DataTypes } from "sequelize";
import { sequelize } from "../config/db";

// User model schema
export const User = sequelize.define("User", {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  firstName: {
    type: DataTypes.STRING(50),
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING(50),
    allowNull: false
  },
  email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true
  },
  password: {
    type: DataTypes.STRING(255),  // will store bcrypt hash
    allowNull: false
  },
  role: {
    type: DataTypes.ENUM("user", "admin"),
    allowNull: false,
    defaultValue: "user"
  }
}, {
  tableName: "Users",
  timestamps: false
});

# src/models/vacation.model.ts
import { DataTypes } from "sequelize";
import { sequelize } from "../config/db";

export const Vacation = sequelize.define("Vacation", {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  destination: {
    type: DataTypes.STRING(100),
    allowNull: false
  },
  description: {
    type: DataTypes.STRING(1000),
    allowNull: false
  },
  startDate: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  price: {
    type: DataTypes.DECIMAL(8, 2),
    allowNull: false
  },
  imageFileName: {
    type: DataTypes.STRING(255),
    allowNull: false
  }
}, {
  tableName: "Vacations",
  timestamps: false
});

# src/models/follower.model.ts
import { DataTypes } from "sequelize";
import { sequelize } from "../config/db";
import { User } from "./user.model";
import { Vacation } from "./vacation.model";

export const Follower = sequelize.define("Follower", {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: User, key: "id" }
  },
  vacationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: Vacation, key: "id" }
  }
}, {
  tableName: "Followers",
  timestamps: false,
  indexes: [
    { unique: true, fields: ["userId", "vacationId"] }  // ensure one follow per user-vacation pair
  ]
});

// Define model associations (Many-to-Many through Followers)
User.belongsToMany(Vacation, { through: Follower, foreignKey: "userId", otherKey: "vacationId" });
Vacation.belongsToMany(User, { through: Follower, foreignKey: "vacationId", otherKey: "userId", as: "followers" });

# src/index.ts
import express from "express";
import cors from "cors";
import { sequelize } from "./config/db";
import authRoutes from "./routes/auth.routes";
import vacationRoutes from "./routes/vacation.routes";
import { authMiddleware } from "./middlewares/auth.middleware";

// Initialize Express app
const app = express();

// Middleware: CORS (allow all origins for development; adjust in production as needed)
app.use(cors());
// Middleware: JSON request body parsing
app.use(express.json());

// now we will do console log for all requests
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url} requast status ${res.statusCode}`);
  next();
});

// Serve images from the uploads folder
app.use("/uploads", express.static("uploads"));

// Routes:
app.use("/api/auth", authRoutes);
// Protect all vacation routes with auth middleware
app.use("/api/vacations", authMiddleware, vacationRoutes);

// Health check (optional)
app.get("/api/health", (_req, res) => res.send("OK"));

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
  try {
    await sequelize.authenticate();
    console.log("Database connected.");
  } catch (err) {
    console.error("Database connection failed:", err);
  }
  console.log(`Server is running on port ${PORT}`);
});

# src/controllers/auth.controller.ts
import { Request, Response } from "express";
import { User } from "../models/user.model";
import bcrypt from "bcrypt";
import { generateToken } from "../utils/jwt";

export const AuthController = {
  // User registration
  register: async (req: Request, res: Response) => {
    try {
      const { firstName, lastName, email, password } = req.body;
      if (!firstName || !lastName || !email || !password) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      // Check if email already exists
      const existing = await User.findOne({ where: { email } });
      if (existing) {
        return res.status(409).json({ message: "Email is already in use" });
      }
      // Hash the password
      const hashed = await bcrypt.hash(password, 10);
      // Create new user (regular user by default)
      const newUser = await User.create({ firstName, lastName, email, password: hashed, role: "user" });
      const userData = {
        id: newUser.get("id"),
        firstName: newUser.get("firstName"),
        lastName: newUser.get("lastName"),
        email: newUser.get("email"),
        role: newUser.get("role")
      };
      // Generate JWT token for the new user
      const token = generateToken({ 
        id: userData.id as number, 
        role: userData.role as string, 
        firstName: userData.firstName as string, 
        lastName: userData.lastName as string 
      });
      return res.status(201).json({ token, user: userData });
    } catch (err) {
      console.error("Error in register:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // User login
  login: async (req: Request, res: Response) => {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }
      // Find user by email
      const user = await User.findOne({ where: { email } });
      if (!user) {
        return res.status(401).json({ message: "Invalid email or password" });
      }
      // Check password
      const passwordMatches = await bcrypt.compare(password, user.get("password") as string);
      if (!passwordMatches) {
        return res.status(401).json({ message: "Invalid email or password" });
      }
      // Prepare user data for response (omit password hash)
      const userData = {
        id: user.get("id"),
        firstName: user.get("firstName"),
        lastName: user.get("lastName"),
        email: user.get("email"),
        role: user.get("role")
      };
      // Generate JWT token
      const token = generateToken({ 
        id: userData.id as number, 
        role: userData.role as string, 
        firstName: userData.firstName as string, 
        lastName: userData.lastName as string 
      });
      return res.json({ token, user: userData });
    } catch (err) {
      console.error("Error in login:", err);
      return res.status(500).json({ message: "Server error" });
    }
  }
};

# src/controllers/vacation.controller.ts
/// <reference path="../types/express/index.d.ts" />

import { Request, Response } from "express";
import { Vacation } from "../models/vacation.model";
import { Follower } from "../models/follower.model";
import { upload } from "../utils/uploader";
import fs from "fs";
import path from "path";
import { sequelize } from "../config/db";
import { QueryTypes } from "sequelize";

export const VacationController = {
  // Get all vacations (for logged-in user or admin)
  getAllVacations: async (req: Request, res: Response) => {
    try {
      const currentUserId = req.user!.id;
      const currentUserRole = req.user!.role;
      // Fetch all vacations sorted by start date
      const vacations = await Vacation.findAll({ order: [["startDate", "ASC"]] });
      // For each vacation, determine followers count and if current user follows it
      const result = [];
      for (const vac of vacations) {
        const plainVac = vac.get({ plain: true });
        const count = await Follower.count({ where: { vacationId: plainVac.id } });
        let isFollowed = false;
        if (currentUserRole !== "admin") {
          // Only check follow status for normal users (admin doesn't follow vacations in UI)
          const followRecord = await Follower.findOne({ where: { userId: currentUserId, vacationId: plainVac.id } });
          isFollowed = followRecord ? true : false;
        }
        result.push({ ...plainVac, followersCount: count, isFollowed });
      }
      return res.json(result);
    } catch (err) {
      console.error("Error getting vacations:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // Get single vacation by ID
  getVacationById: async (req: Request, res: Response) => {
    try {
      const vacId = req.params.id;
      const vacation = await Vacation.findByPk(vacId);
      if (!vacation) {
        return res.status(404).json({ message: "Vacation not found" });
      }
      return res.json(vacation.get({ plain: true }));
    } catch (err) {
      console.error("Error getting vacation:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // Admin: create a new vacation
  createVacation: async (req: Request, res: Response) => {
    try {
      // `upload.single('image')` middleware will have processed the file if any
      const { destination, description, startDate, endDate, price } = req.body;
      // Basic validation
      if (!destination || !description || !startDate || !endDate || !price) {
        return res.status(400).json({ message: "All fields are required" });
      }
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      if (end < start) {
        return res.status(400).json({ message: "End date cannot be before start date" });
      }
      const now = new Date();
      // Do not allow creating vacations entirely in the past
      if (end < now) {
        return res.status(400).json({ message: "Vacation dates cannot be entirely in the past" });
      }
      const priceNum = parseFloat(price);
      if (priceNum < 0 || priceNum > 10000) {
        return res.status(400).json({ message: "Price must be between 0 and 10000" });
      }
      // Handle image file if provided
      let imageFileName = "no-image.jpg";
      if (req.file) {
        imageFileName = req.file.filename;  // filename set by multer
      } else {
        // If no file uploaded, we could use a default image or return an error.
        // Here we choose to require an image:
        return res.status(400).json({ message: "Image is required" });
      }
      // Create vacation record
      const newVac = await Vacation.create({ destination, description, startDate, endDate, price: priceNum, imageFileName });
      return res.status(201).json(newVac.get({ plain: true }));
    } catch (err: any) {
      console.error("Error creating vacation:", err);
      return res.status(500).json({ message: err.message || "Server error" });
    }
  },

  // Admin: update an existing vacation
  updateVacation: async (req: Request, res: Response) => {
    try {
      const vacId = req.params.id;
      const vacation = await Vacation.findByPk(vacId);
      if (!vacation) {
        return res.status(404).json({ message: "Vacation not found" });
      }
      const { destination, description, startDate, endDate, price } = req.body;
      // Validate fields (allow partial updates except we expect all fields in form except image)
      if (!destination || !description || !startDate || !endDate || !price) {
        return res.status(400).json({ message: "All fields (except image) are required" });
      }
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      if (end < start) {
        return res.status(400).json({ message: "End date cannot be before start date" });
      }
      const priceNum = parseFloat(price);
      if (priceNum < 0 || priceNum > 10000) {
        return res.status(400).json({ message: "Price must be between 0 and 10000" });
      }
      // If a new image file is uploaded, handle it
      let imageFileName = vacation.get("imageFileName") as string;
      if (req.file) {
        // Remove old image file from server if exists
        const oldFile = imageFileName;
        if (oldFile && fs.existsSync(path.join("uploads", oldFile))) {
          fs.unlinkSync(path.join("uploads", oldFile));
        }
        imageFileName = req.file.filename;
      }
      // Update fields
      await Vacation.update(
        { destination, description, startDate, endDate, price: priceNum, imageFileName },
        { where: { id: vacId } }
      );
      const updated = await Vacation.findByPk(vacId);
      return res.json(updated!.get({ plain: true }));
    } catch (err) {
      console.error("Error updating vacation:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // Admin: delete a vacation
  deleteVacation: async (req: Request, res: Response) => {
    try {
      const vacId = req.params.id;
      const vacation = await Vacation.findByPk(vacId);
      if (!vacation) {
        return res.status(404).json({ message: "Vacation not found" });
      }
      // Delete associated follower records (if not handled by DB cascade)
      await Follower.destroy({ where: { vacationId: vacId } });
      // Remove the vacation
      await Vacation.destroy({ where: { id: vacId } });
      // Delete the image file from disk, if exists
      const imageFileName = vacation.get("imageFileName") as string;
      if (imageFileName && fs.existsSync(path.join("uploads", imageFileName))) {
        fs.unlinkSync(path.join("uploads", imageFileName));
      }
      return res.json({ message: "Vacation deleted" });
    } catch (err) {
      console.error("Error deleting vacation:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // User: follow a vacation
  followVacation: async (req: Request, res: Response) => {
    try {
      const vacId = req.params.id;
      const userId = req.user!.id;
      // Check if already followed
      const exists = await Follower.findOne({ where: { userId, vacationId: vacId } });
      if (exists) {
        return res.status(400).json({ message: "Already following this vacation" });
      }
      await Follower.create({ userId, vacationId: vacId });
      return res.status(201).json({ message: "Followed vacation" });
    } catch (err) {
      console.error("Error following vacation:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // User: unfollow a vacation
  unfollowVacation: async (req: Request, res: Response) => {
    try {
      const vacId = req.params.id;
      const userId = req.user!.id;
      const deleted = await Follower.destroy({ where: { userId, vacationId: vacId } });
      if (!deleted) {
        return res.status(400).json({ message: "Not following this vacation" });
      }
      return res.json({ message: "Unfollowed vacation" });
    } catch (err) {
      console.error("Error unfollowing vacation:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // Admin: get vacation followers report (JSON data)

  getFollowReport: async (req: Request, res: Response) => {
    try {
      const rows = await sequelize.query<{ destination: string; followersCount: number }>(
        `SELECT v.destination AS destination, COUNT(f.userId) AS followersCount
         FROM Vacations v 
         LEFT JOIN Followers f ON v.id = f.vacationId
         GROUP BY v.id
         ORDER BY v.destination;`,
        { type: QueryTypes.SELECT }
      );
      return res.json(rows);
    } catch (err) {
      console.error("Error generating report:", err);
      return res.status(500).json({ message: "Server error" });
    }
  },

  // Admin: get vacation followers report in CSV format
    getFollowReportCSV: async (req: Request, res: Response) => {
    try {
      // Use the same technique for the CSV version.
      const rows = await sequelize.query<{ destination: string; followersCount: number }>(
        `SELECT v.destination AS destination, COUNT(f.userId) AS followersCount
         FROM Vacations v 
         LEFT JOIN Followers f ON v.id = f.vacationId
         GROUP BY v.id
         ORDER BY v.destination;`,
        { type: QueryTypes.SELECT }
      );
      let csv = "Destination,FollowersCount\n";
      for (const row of rows) {
        csv += `${row.destination},${row.followersCount}\n`;
      }
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", "attachment; filename=vacations_report.csv");
      return res.send(csv);
    } catch (err) {
      console.error("Error generating CSV report:", err);
      return res.status(500).json({ message: "Server error" });
    }
  }
};

# src/routes/vacation.routes.ts
import { Router } from "express";
import { VacationController } from "../controllers/vacation.controller";
import { adminMiddleware } from "../middlewares/admin.middleware";
import { upload } from "../utils/uploader";

const router = Router();

// All routes in this router are already behind authMiddleware (see index.ts)

// Get all vacations (for logged-in users and admins)
router.get("/", VacationController.getAllVacations);

// Get one vacation by ID (for editing/viewing details)
router.get("/:id", VacationController.getVacationById);

// Follow/unfollow endpoints for users
router.post("/:id/follow", VacationController.followVacation);
router.delete("/:id/follow", VacationController.unfollowVacation);

// Admin-only vacation management
router.post("/", adminMiddleware, upload.single("image"), VacationController.createVacation);
router.put("/:id", adminMiddleware, upload.single("image"), VacationController.updateVacation);
router.delete("/:id", adminMiddleware, VacationController.deleteVacation);

// Admin-only report endpoints
router.get("/report/csv", adminMiddleware, VacationController.getFollowReportCSV);

router.get("/report", adminMiddleware, VacationController.getFollowReport);

export default router;

# src/routes/auth.routes.ts
import { Router } from "express";
import { AuthController } from "../controllers/auth.controller";

const router = Router();

// Public routes for authentication
router.post("/register", AuthController.register);
router.post("/login", AuthController.login);

export default router;

